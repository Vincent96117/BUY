<!DOCTYPE html>
<html>
<head>
    <title>ä¸‰äººçµæ®ºåœ˜ V3.1-Final</title>
    <style>
        body { background: #111; color: #eee; font-family: sans-serif; margin: 20px; }
        .dashboard { display: flex; gap: 20px; margin-bottom: 20px; align-items: center; background: #222; padding: 15px; border-radius: 8px; border: 1px solid #444; }
        table { width: 100%; border-collapse: collapse; }
        th, td { padding: 10px; border: 1px solid #333; text-align: left; }
        .SCAN { color: #666; }
        .READY { color: #ffeb3b; font-weight: bold; background: rgba(255, 235, 59, 0.1); }
        .ENTRY { color: #fff; background: #ff0000; font-weight: bold; animation: pulse 0.5s infinite; }
        .HOLD { color: #00ff00; font-weight: bold; background: rgba(0, 255, 0, 0.1); }
        .pinned { background: #2a2a2a !important; border-left: 5px solid #ffeb3b !important; }
        @keyframes pulse { 0% { opacity: 1; } 50% { opacity: 0.5; } 100% { opacity: 1; } }
        button { padding: 10px 20px; cursor: pointer; border: none; border-radius: 4px; font-weight: bold; }
        .btn-pin { padding: 5px 10px; background: #444; color: white; }
        .btn-pin.active { background: #ffeb3b; color: black; }
        #status { margin-left: auto; color: #00ffff; font-weight: bold; }
        .tp-text { display: block; color: #00ff00; font-size: 11px; margin-top: 3px; font-weight: bold; }
    </style>
</head>
<body>

    <div class="dashboard">
        <div style="font-size: 20px; font-weight: bold; color: #ffeb3b;">ä¸‰äººçµæ®ºåœ˜ V3.1-Fix</div>
        <button style="background: #d32f2f; color: white;" onclick="toggleSystem()" id="startBtn">ğŸš€ å•Ÿå‹•ç›£æ§</button>
        <button style="background: #0088cc; color: white; margin-left: 10px;" onclick="testPush()">ğŸ§ª æ¸¬è©¦ç¾¤çµ„æ¨æ’­</button>
        <div id="status">ç³»çµ±å°±ç·’</div>
    </div>

    <table>
        <thead>
            <tr>
                <th>é‡˜é¸</th>
                <th>ä¸Šæ¦œæ™‚é–“</th>
                <th>æ¨™çš„</th>
                <th>åƒ¹æ ¼ / 3D é«˜é»</th>
                <th>è·é›¢ %</th>
                <th>è³‡è²»</th>
                <th>ç‹€æ…‹</th>
                <th>OI è®Šå‹• / TP</th>
            </tr>
        </thead>
        <tbody id="radarBody"></tbody>
    </table>

<script>
    const CONFIG = {
        PO_USER: "Gkhqyhobnxzjfwgvaiyp347m1jkhn4", 
        PO_TOKEN: "acyoe3sz15x4n91r1349fdcau7x6pw", 
        BLACKLIST: ['BTCUSDT', 'ETHUSDT', 'SOLUSDT', 'XRPUSDT', 'BNBUSDT', 'BNXUSDT']
    };

    let isRunning = false, notifiedStatus = {}, signalTimes = {}, lastOI = {}, allData = {}, pinnedSymbols = new Set();
    let entryPoints = {}, lastPushedTP = {};

    // --- ğŸ® ä¿®æ­£ç‰ˆæ¨æ’­å‡½æ•¸ (ç•°æ­¥ä¸é˜»å¡) ---
    async function sendPush(title, message) {
        if (!title || !message) return;
        
        // èªéŸ³å„ªå…ˆéŸ¿èµ·ï¼Œçµ¦äºˆå³æ™‚é«”æ„Ÿ
        window.speechSynthesis.cancel();
        const msg = new SpeechSynthesisUtterance(title);
        msg.lang = 'zh-TW';
        window.speechSynthesis.speak(msg);

        // ä½¿ç”¨ fetch çš„èƒŒæ™¯ç™¼é€ï¼Œä¸ä½¿ç”¨ await ç­‰å¾…å›å‚³ï¼Œé¿å…å¡ä½ä¸»ç¨‹å¼
        const params = new URLSearchParams({ 
            token: CONFIG.PO_TOKEN, user: CONFIG.PO_USER, 
            title: title, message: message, 
            priority: "1", sound: "classical" 
        });

        fetch('https://api.pushover.net/1/messages.json', { 
            method: 'POST', 
            headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
            body: params.toString()
        }).catch(e => console.error("Push Failed", e));
    }

    function testPush() { sendPush("æ¸¬è©¦é€šçŸ¥", "æ¨æ’­ç³»çµ±æ­£å¸¸ï¼Œé€£ç·šç©©å®šã€‚"); alert("å·²ç™¼å‡ºæ¸¬è©¦è«‹æ±‚ï¼Œè«‹æŸ¥çœ‹æ‰‹æ©Ÿã€‚"); }
    function togglePin(symbol) { pinnedSymbols.has(symbol) ? pinnedSymbols.delete(symbol) : pinnedSymbols.add(symbol); render(); }

    async function getSingleOI(symbol) {
        try {
            const res = await fetch(`https://fapi.binance.com/fapi/v1/openInterest?symbol=${symbol}`);
            const data = await res.json();
            return parseFloat(data.openInterest);
        } catch (e) { return null; }
    }

    async function get3DHigh(symbol) {
        try {
            const res = await fetch(`https://fapi.binance.com/fapi/v1/klines?symbol=${symbol}&interval=1d&limit=3`);
            const data = await res.json();
            return Math.max(...data.map(k => parseFloat(k[2])));
        } catch (e) { return null; }
    }

    async function mainLoop() {
        if (!isRunning) return;
        try {
            const [pRes, fRes] = await Promise.all([
                fetch('https://fapi.binance.com/fapi/v1/ticker/price'),
                fetch('https://fapi.binance.com/fapi/v1/premiumIndex')
            ]);
            const prices = await pRes.json(), funds = await fRes.json();

            const eligible = funds.filter(f => 
                f.symbol.endsWith('USDT') && !CONFIG.BLACKLIST.includes(f.symbol) && Math.abs(parseFloat(f.lastFundingRate)) >= 0.0005
            ).map(f => f.symbol);

            const symbolsToProcess = new Set([...eligible, ...pinnedSymbols]);

            for (let symbol of symbolsToProcess) {
                // æ¸›å°‘å»¶é²åˆ° 50msï¼ŒåŠ é€Ÿæƒæ
                await new Promise(r => setTimeout(r, 50));

                if (!allData[symbol]) {
                    const high = await get3DHigh(symbol);
                    if (high) allData[symbol] = { high }; else continue;
                }
                const currentOI = await getSingleOI(symbol);
                if (currentOI === null) continue;

                const fInfo = funds.find(f => f.symbol === symbol);
                const pInfo = prices.find(p => p.symbol === symbol);
                
                const high = allData[symbol].high;
                const price = parseFloat(pInfo.price);
                const fund = (parseFloat(fInfo.lastFundingRate) * 100).toFixed(4);
                const dist = ((high - price) / high * 100).toFixed(2);
                const oiChange = lastOI[symbol] ? ((currentOI - lastOI[symbol]) / lastOI[symbol] * 100).toFixed(2) : 0;
                lastOI[symbol] = currentOI;

                let st = "SCAN";
                let old = notifiedStatus[symbol] || "SCAN";

                const isEntry = price >= high || (dist <= 1.5 && oiChange > 0.8);
                const keepHold = (old === "ENTRY" || old === "HOLD") && (price >= high * 0.99 && oiChange > -1.5);

                if (keepHold) st = "HOLD";
                else if (eligible.includes(symbol) && isEntry) st = "ENTRY";
                else if (eligible.includes(symbol) && dist <= 1.5) st = "READY";

                // --- ğŸ¯ TP èˆ‡æ¨æ’­é‚è¼¯ ---
                let tpTag = "";
                if (st === "ENTRY") {
                    if (!entryPoints[symbol]) entryPoints[symbol] = { p: price, f: parseFloat(fund) };
                    let fShift = Math.abs(parseFloat(fund) - entryPoints[symbol].f);
                    let boost = (fShift / 0.01 * 0.5) + (Math.max(0, oiChange) / 5 * 1.0);
                    let tpPrice = entryPoints[symbol].p * (1 + (boost / 100));
                    tpTag = `<span class="tp-text">ğŸ¯TP: ${tpPrice.toFixed(4)}</span>`;

                    // TP æœ‰æ„Ÿä¸Šä¿®æ¨æ’­
                    if (tpPrice > (lastPushedTP[symbol] || 0) * 1.005) {
                        sendPush(`ğŸ¯ TPä¸Šä¿®: ${symbol}`, `åƒ¹:${price} æ¨™:${tpPrice.toFixed(4)}`);
                        lastPushedTP[symbol] = tpPrice;
                    }
                } else if (st !== "HOLD") {
                    delete entryPoints[symbol]; delete lastPushedTP[symbol];
                }

                if (st !== "SCAN" && !signalTimes[symbol]) signalTimes[symbol] = new Date().toLocaleTimeString();
                
                // ç‹€æ…‹æ”¹è®Šç«‹å³æ¨æ’­ï¼ˆåŒ…å« READYï¼‰
                if (st !== old && st !== "SCAN") {
                    sendPush(`${st}: ${symbol}`, `åƒ¹:${price} è·:${dist}% OI:${oiChange}%`);
                }
                
                notifiedStatus[symbol] = st;
                allData[symbol].row = { time: signalTimes[symbol] || "--", symbol, price, high, dist, fund, st, oiChange, tpTag };
            }

            render();
            document.getElementById('status').innerText = "âœ… ç›£æ§ä¸­ (15s)";
        } catch (e) { console.error(e); }
    }

    function render() {
        const rows = Object.values(allData).filter(d => d.row).map(d => d.row);
        const sorted = rows.sort((a, b) => pinnedSymbols.has(a.symbol) ? -1 : pinnedSymbols.has(b.symbol) ? 1 : a.dist - b.dist);
        document.getElementById('radarBody').innerHTML = sorted.map(c => `
            <tr class="${pinnedSymbols.has(c.symbol) ? 'pinned' : ''}">
                <td><button class="btn-pin ${pinnedSymbols.has(c.symbol) ? 'active' : ''}" onclick="togglePin('${c.symbol}')">ğŸ“Œ</button></td>
                <td>${c.time}</td>
                <td><b>${c.symbol}</b></td>
                <td>${c.price} / ${c.high}</td>
                <td style="color:${c.dist < 0 ? '#00ff00' : '#ff4444'}">${c.dist}%</td>
                <td>${c.fund}%</td>
                <td class="${c.st}">${c.st}</td>
                <td>${c.oiChange}% ${c.tpTag}</td>
            </tr>
        `).join('');
    }

    function toggleSystem() {
        isRunning = !isRunning;
        document.getElementById('startBtn').innerText = isRunning ? "ğŸ›‘ åœæ­¢" : "ğŸš€ å•Ÿå‹•";
        if (isRunning) { mainLoop(); setInterval(mainLoop, 15000); }
    }
</script>
</body>
</html>
